var documenterSearchIndex = {"docs":
[{"location":"api.html#Library","page":"函数库","title":"Library","text":"","category":"section"},{"location":"api.html#目录","page":"函数库","title":"目录","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#导出函数","page":"函数库","title":"导出函数","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"getDatas","category":"page"},{"location":"api.html#DoubleRFs.getDatas","page":"函数库","title":"DoubleRFs.getDatas","text":"getDatas(nJ::Int64, nθ::Int64, times_of_σz::Float64, funψzδ, par::ParDBRF)\n\n对双高频相空间进行采样。\n\nParameters\n\nnJ: 径向采样点数。\n\nnθ: 角向采样点数。需要满足一定的公式。你输入的不合适程序会给出建议。根据经验，以99结尾都可以，199,299,...等等。\n\ntimes_of_σz: Sample radius from extreme point.\n\nfunψzδ: Density distribution of z, δ.\n\npar: parameters of double RFs. struct: ParDBRF\n\nReturn\n\nEJ: 被采样的哈密顿量。\n\nJJ: 与哈密顿量对应的作用量。\n\nΔJJ: 采样作用量步长。这里不是简单将JJ相邻两个相减，因为过拉伸时，头部和尾部、尾部和外围作用量之间存在跳跃，所以需要独自计算。\n\nzJθ: 每个相空间采样点的z坐标。\n\nδJθ: 每个相空间采样点的δ坐标。\n\nϕJθ: 每个相空间采样点的角变量ϕ坐标。\n\nνsJ: JJ处的纵向振荡工作点. 纵向工作点的定义为ωs(J)/ω0，其中ωs(J)通过正则变换dotphi=partial H  partial J确定。\n\nψJ: 与JJ对应的径向密度分布.\n\nnJ: JJ的长度。返回的类型有两种，只有一个SFP时，就是JJ的长度；有两个SFP时，分为头部、尾部、外围的采样点长度。\n\n\n\n\n\ngetDatas(nJ::Int64, nθ::Int64, times_of_σz::Float64, zvec::Vector, ρvec::Vector, par::ParDBRF)\n\n获取双高频系统相空间采样点数据。\n\nParameters\n\nnJ: 径向采样点。\n\nnθ: 角向采样点数。因为需要考虑过拉伸一个环和两个环，角向采样点数要一致。所以这里不管欠拉伸还是过拉伸，统一要求nθ满足特定公式。可以先number_angle_samples(nθ)=nθ判断一下。根据经验，199,299,399都是可以的。\n\ntimes_of_σz: σz的倍数。\n\nReturn\n\nEJ: 被采样的哈密顿量。\n\nJJ: 与哈密顿量对应的作用量。\n\nΔJJ: 采样作用量步长。这里不是简单将JJ相邻两个相减，因为过拉伸时，头部和尾部、尾部和外围作用量之间存在跳跃，所以需要独自计算。\n\nzJθ: 每个相空间采样点的z坐标。\n\nδJθ: 每个相空间采样点的δ坐标。\n\nϕJθ: 每个相空间采样点的角变量ϕ坐标。\n\nνsJ: JJ处的纵向振荡工作点. 纵向工作点的定义为ωs(J)/ω0，其中ωs(J)通过正则变换dotphi=partial H  partial J确定。\n\nψJ: 与JJ对应的径向密度分布.\n\nnJ: JJ的长度。返回的类型有两种，只有一个SFP时，就是JJ的长度；有两个SFP时，分为头部、尾部、外围的采样点长度。\n\n\n\n\n\n","category":"function"},{"location":"api.html","page":"函数库","title":"函数库","text":"scanNb","category":"page"},{"location":"api.html#DoubleRFs.scanNb","page":"函数库","title":"DoubleRFs.scanNb","text":"scanNb(ratiovec, Nb, JJ, ΔJJ, ψJ, νsJ, zJθ, ΦJθ, ωvec, imp_trans, lm, par::ParDBRF)\n\n对单束团电荷数进行扫描。\n\n\n\nParameters\n\nratiovec: Vector 需要扫描的“流强与最大流强的比例”。\n\nNb: 束团电子数。\n\nJJ: 作用量采样点。\n\nΔJJ: 采样作用量步长。之所以需要提前算，是因为过拉伸时，头部和尾部、尾部和外围作用量之间存在跳跃。\n\nψJ: 与JJ对应的径向密度分布.\n\nνsJ: JJ处的纵向振荡工作点. 纵向工作点的定义为ωs(J)/ω0，其中ωs(J)通过正则变换dotphi=partial H  partial J确定。\n\nzJθ,ΦJθ: samples of z and angle variable. First and second dimension/index correspond to J and θ, action and angle variable samples, respectively.\n\nωvec,imp_trans: Real ω Vector and complex impedance Vector of impedance data. Here ωvec should be all frequency, not just positive.\n\nlm: 最大角向模数.\n\npar: ParDBRF, 双高频系统参数.\n\n\n\nReturn\n\nratios: 扫描电荷量与束团电荷量的比值ratio的列表。 和下面两个都能形成数值对。由于一个电荷量存在多个频率，以及多个增长率。为了保证数据配对，这里将比值相应复制了多份。\n\ngrowthRates: Vector. 与ratios对应的每秒增长率.\n\ntuneShifts: Vector. 与ratios对应的频移.\n\n\n\n\n\n","category":"function"},{"location":"api.html#参数结构体","page":"函数库","title":"参数结构体","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"ParDBRF","category":"page"},{"location":"api.html#DoubleRFs.ParDBRF","page":"函数库","title":"DoubleRFs.ParDBRF","text":"ParDBRF(v1, r, ϕs, ϕ2s, h1, h, circum, centerenergy, αc, ξ, νy, σδ)::ParDBRF\n\n为了避免反复输入很多参数，将双高频系统和环的参数塞进统一结构体。\n\nParameters:\n\nv1: 主腔电压，单位[V]\n\nr: 高频腔和主腔电压之比，单位[1]\n\nϕs: 主腔相位，单位[rad]\n\nϕ2s: 高频腔相位，单位[rad]\n\nh1: 主腔周期数，单位[1]\n\nh: 高频腔周期数，单位[1]\n\ncircum: 轨迹周期，单位[m]\n\ncenterenergy: 质子中心能量，单位[eV]\n\nαc: 质子中心能量对应的相对论因子\n\nξ: 质子中心能量对应的相对论因子\n\nνy: 横向振荡工作点，即，单位[1]\n\nσδ: 束团能散\n\nReturn:\n\n参数结构体ParDBRF，函数和结构体同名，是利用了多重分派特性。\n\n\n\n\n\n","category":"type"},{"location":"api.html#Basic-Equations","page":"函数库","title":"Basic Equations","text":"","category":"section"},{"location":"api.html#电压","page":"函数库","title":"电压","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"The total voltage is:","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"V_tot(z) =V_1 mathcalV(z) - 4 pi epsilon_0 N_b e int_z^infty dz rho(z) W_0(z-z)","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"where","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"mathcalV(z)=sinleft( phi_s-dfrac2h_1piCz right)-sinphi_s+rsinleftphi_2s-dfrac2h_1 h piCz right-rsinphi_2s","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":", called normed voltage. The first term of RHS of V_tot(z) is cavity voltage and second term is wake voltage.","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"getCavityVoltage","category":"page"},{"location":"api.html#DoubleRFs.getCavityVoltage","page":"函数库","title":"DoubleRFs.getCavityVoltage","text":"getCavityVoltage(z, v1, r, ϕs, ϕ2s, h1, h, circum)\n\n双高频腔压。\n\nz: Float64. 相对于参考粒子的纵向位置。z0表示头部。单位[m]。\n\nv1: Float64. 主腔腔压。单位[V]。\n\nr: Float64. 高频腔和主腔电压之比。\n\nϕs: Float64。主腔相位。单位[rad]。\n\nϕ2s: Float64。高频腔相位。单位[rad]。\n\nh1: Int64。主腔谐波数，为主腔频率omega_textPrimary与回旋频率omega_0的比值h_1 = omega_textPrimaryomega_0。\n\nh: Int64. 高频腔和主腔谐波数之比。\n\ncircum: Float64. 储存环周长。单位[m]。\n\n\n\n\n\ngetCavityVoltage(z, par::ParDBRF)\n\n双高频腔压。\n\nz: Float64. 相对于参考粒子的纵向位置。z0表示头部。单位[m]。\n\npar: ParDBRF. 打包的参数结构体，不过ParDBRF中打包的参数比这里需要的参数多，详情见ParDBRF。如果没有那么多参数的话，还是用另一个版本吧。\n\n\n\n\n\n","category":"function"},{"location":"api.html#电压导数","page":"函数库","title":"电压导数","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"DoubleRFs.∇normedVoltage","category":"page"},{"location":"api.html#DoubleRFs.∇normedVoltage","page":"函数库","title":"DoubleRFs.∇normedVoltage","text":"∇normedVoltage(z, ϕs::Float64, ϕ2s::Float64, r::Float64, h1::Int64, h::Int64, circum::Float64)::Float64\n\n归一化电压的1阶导数。\n\n\n\n\n\n∇normedVoltage(z, par::ParDBRF)::Float64\n\n归一化电压的1阶导数。\n\n\n\n\n\n","category":"function"},{"location":"api.html#Hamiltonian","page":"函数库","title":"Hamiltonian","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"我们这里采取的哈密顿量形式为：","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"H(zdeltas)=-dfraceta_p2delta^2-dfraceV_12pi h_1 EmathcalP(z)+dfrac4 pi epsilon_0 N_0 r_egamma Cint_0^zdz int_z^infty dz rho(z) W_0(z-z)","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"这里：","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"mathcalP(z)= cosleft( phi_s - dfrac2 pi h_1Cz right)+dfracrh cosleft( phi_2s-dfrac2pi h_2Cz right)+left(-dfrac2pi h_1Czright)left(sinphi_s+rsinphi_2sright)-cosphi_s-dfracrhcosphi_2s","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"the second and the last term in RHS of H(zdeltas) is our \"cavity potential\" and \"wake potential\".(see getPotenCavity and getPotenWake)","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"The Hamiltonian with this form H(z delta s) looks like an inverted bowl.","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"hamiltonian","category":"page"},{"location":"api.html#DoubleRFs.hamiltonian","page":"函数库","title":"DoubleRFs.hamiltonian","text":"Hamiltonian(z::Float64, δ::Float64, v1, r::Float64, ϕs::Float64, ϕ2s::Float64, η::Float64, h1::Int64, h::Int64, circum::Float64, centerenergy::Float64)\n\nGet Hamiltonian with harmonic cavity but without wake.\n\nHamiltonian here has the form: H=H(zδs).\n\nParameters\n\nz: z=s-ct. z0 is the head of the bunch.\n\nδ:\n\nv1:\n\nr:\n\nϕs:\n\nϕ2s:\n\nηp:\n\nh1: Defaut value is 756, parmeter of HEPS.\n\nh: Defaut value is 3, parmeter of HEPS.\n\ncenterenergy: Defaut value is 6e9, parmeter of HEPS.\n\n\n\n\n\nhamiltonian(z::Float64, δ::Float64, par::ParDBRF)\n\n哈密顿量\n\n\n\n\n\nGet Hamiltonian with harmonic cavity but without wake.\n\nHamiltonian here has the form: H=H(zδs).\n\nParameters\n\nz:z=s-ct.z>0` is the head of the bunch.\n\nδ:\n\nv1:\n\nr:\n\nϕs:\n\nϕ2s:\n\nfunWakePoten: Wake potential function. Type of Interpolations.Extrapolation or Function.\n\nηp:\n\nh1: Defaut value is 756, parmeter of HEPS.\n\nh: Defaut value is 3, parmeter of HEPS.\n\ncenterenergy: Defaut value is 6e9, parmeter of HEPS.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Density-Distribution","page":"函数库","title":"Density Distribution","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"容易发现，","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"expleft( fracH(z delta s)eta_p sigma_delta^2 right)","category":"page"},{"location":"api.html","page":"函数库","title":"函数库","text":"关于delta是纯高斯的。这很符合一种称为Haissinski分布。分解去delta剩下的关于z的就是纵向分布rho(z)。","category":"page"},{"location":"api.html#Potential-Term-in-Hamiltonian","page":"函数库","title":"Potential Term in Hamiltonian","text":"","category":"section"},{"location":"api.html#Hamiltonian-2","page":"函数库","title":"Hamiltonian","text":"","category":"section"},{"location":"api.html#Density-Distribution-2","page":"函数库","title":"Density Distribution","text":"","category":"section"},{"location":"api.html#Synchrotron-Tunes","page":"函数库","title":"Synchrotron Tunes","text":"","category":"section"},{"location":"api.html","page":"函数库","title":"函数库","text":"getBucketBounds","category":"page"},{"location":"api.html#DoubleRFs.getBucketBounds","page":"函数库","title":"DoubleRFs.getBucketBounds","text":"getBucketBounds(ϕs, ϕ2s, v1, r, h1, h, circum, centerenergy, αc; tol = 1.0e-12, max_try_time = 50)\n\n计算相稳定区边界\n\n\n\nParameters\n\nϕ2: 参考粒子主腔相位。单位弧度。\n\nϕ2s: 参考粒子谐波腔相位。单位弧度。\n\nv1: 主腔电压。\n\nr: 谐波腔与主腔电压之比。\n\nh1: 主腔的谐波数.\n\nh: 两个腔谐波数之比.\n\ncircum: 储存环周长.\n\ncenterenergy: 参考粒子能量.\n\nαc: 动量压缩因子.\n\nReturn\n\nzL,zR: bucket的上下限。\n\n\n\n\n\ngetBucketBounds(par::ParDBRF; tol = 1.0e-12, max_try_time = 50)\n\n计算相稳定区边界\n\n\n\nParameters\n\npar: ParDBRF。包含加速器与双高频系统参数的参数结构体。\n\nReturn\n\nzL,zR: bucket的上下限。\n\n\n\n\n\n","category":"function"},{"location":"examples.html","page":"示例","title":"示例","text":"下面用HEPS参数演示用法。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"首先，为了方便，先将加速器参数打包进一个结构体中：","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"par = ParDBRF(3.6759e6, 0.1908, 2.0391, 5.6879795185567140, 756, 3, 1360.4, 6e9, 1.56e-5, 0, 106.27, 1.06e-3)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"这里的各个数值参考函数ParDBRF的变量含义——在左边搜索框搜索即可。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"这里参数实际有的时候是不必要的，比如你只想要纵向密度分布，nu_y是没有必要的，随便填点就可以。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"","category":"page"},{"location":"examples.html#双高频纵向密度分布","page":"示例","title":"双高频纵向密度分布","text":"","category":"section"},{"location":"examples.html","page":"示例","title":"示例","text":"zvec, ρvec = getNormedDensity(par)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"程序会先计算出相稳定区的左右边界，然后在其中均分10_0001个点，并计算相应归一化密度分布。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"该程序无法考虑纵向阻抗。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"note: 需要时刻保证纵向密度分布是否光滑\n这里选用10_0001个点，有点多。因为存在一些极端情况，粒子只占相稳定区中间极少部分。这种情况下，如果粒子数仅取1000个，则相应曲线就不光滑，甚至都看不到峰值。这10_0001个点是我写死的。不敢保证你的参数下，这10w个点是否足够。所以，最好画出来观察。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"","category":"page"},{"location":"examples.html#计算束长","page":"示例","title":"计算束长","text":"","category":"section"},{"location":"examples.html","page":"示例","title":"示例","text":"σz = getRMSWidth(zvec, ρvec)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"计算rho(z)的RMS宽度。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"","category":"page"},{"location":"examples.html#双高频系统纵向工作点分布","page":"示例","title":"双高频系统纵向工作点分布","text":"","category":"section"},{"location":"examples.html","page":"示例","title":"示例","text":"zvec, νsvec = getSynchrotronTunes(numPoints, par)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"根据加速器参数par，以及采样点数numPoints计算纵向位置zvec以及相应位置的工作点νsvec。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"note: 注意画出来观察一下\n不知道什么原因，有时程序在个别的点，会算出两倍的频率结果。我知道这个结果是错的，所以我通常会手动降低采样点数，这通常能解决这个问题。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"note: 这一段对于分析不稳定性是不必要的\n如果你只是想分析双高频系统不稳定性，没必要运行这一段。这一段是用来单独观察纵向工作点分布nu_s(z)的。双高频不稳定性的代码中，有单独的通过正则变换计算方法得到nu_s(J)。而且这里zvec和前面纵向密度分布变量重名，你不注意就会覆盖掉前面的zvec并产生冲突。如果你非要在同一个代码中运行，请注意更改变量名。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"","category":"page"},{"location":"examples.html#双高频系统不稳定性分析","page":"示例","title":"双高频系统不稳定性分析","text":"","category":"section"},{"location":"examples.html","page":"示例","title":"示例","text":"计算不稳定性，需要先对相空间采样，再根据采样点分析不稳定性。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"计算采样点有两种方法：","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"一种是我常用的，纯双高频系统、没有势阱畸变的。\n一种我没怎么用过，原本是为了纵向势阱畸变留的方案：根据具体potential进行计算。","category":"page"},{"location":"examples.html#纯双高频系统","page":"示例","title":"纯双高频系统","text":"","category":"section"},{"location":"examples.html","page":"示例","title":"示例","text":"如果是纯双高频系统，则可直接用下面的方式获得相空间采样：","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"EJ, JJ, ΔJJ, zJθ, δJθ, ΦJθ, νsJ, ψJ, nJs = getDatas(200, 199, 3σz, zvec, ρvec, par)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"画出来的采样最好再观察一下，特别是过拉伸，哪部分是头部采样点、哪部分是尾部、有没有漏掉的，最好看看。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"得到采样之后，可以利用采样数据分析不稳定性。下面的程序展示的0~0.5nC的不稳定性结果。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"rvec, gvec, tvec=scanNb(collect(0:0.02:1), 0.5 * 1e-9/elementcharge, JJ, ΔJJ, ψJ, νsJ, zJθ, ΦJθ, ωvec, imp_trans, 3, par)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"这里rvec是归一化的电荷量，表示的是N/Nb；gvec表示每秒增长率；tvec表示频移；elementcharge表示元电荷量，需要自己定义const elementcharge = 1.6e-19。","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"note: 阻抗的处理\n这里采用的阻抗是全频域的阻抗，频率单位是rad/s。通常ELEGANT导出的阻抗是正频域的，频率单位是GHz。所以需要统一下格式，直接算肯定是错误的。如果是ELEGANT导出的阻抗，可以用下面的代码处理一下：using CSV, DataFrames\n\nfunction read_impedance(path::String=raw\"./ZTransverse_f_Re_Im.csv\")\n    df=CSV.read(path, DataFrame, header=[\"f[GHz]\",\"Re\",\"Im\"])\n    tmpωvec = 1e9 * 2π * df[!, \"f[GHz]\"]\n    tmpreal = df[!, \"Re\"]\n    tmpimag = df[!,\"Im\"]\n    ωvec = vcat(-tmpωvec[end:-1:1], tmpωvec)\n    reZ = vcat(-tmpreal[end:-1:1], tmpreal)\n    imZ = vcat(tmpimag[end:-1:1], tmpimag)\n    ωvec, reZ .+ 1.0im .* imZ\nend这里没有CSV和DataFrames包的话，需要先安装一下。这两个一个是读取csv文件的包，一个是处理DataFrame的包。","category":"page"},{"location":"examples.html#双高频系统势阱畸变","page":"示例","title":"双高频系统+势阱畸变","text":"","category":"section"},{"location":"examples.html","page":"示例","title":"示例","text":"如果包含势阱畸变，先要求出准确的zvec, ρvec，根据rho(z)，计算直角坐标系中(zdelta)相空间的密度分布psi(zdelta)：","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"funψzδ(z, δ)=LinearInterpolation(zvec, ρvec)(z)*1/(sqrt(2π)*par.σδ)*exp(-0.5*(δ/par.σδ)^2)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"还要计算势能的函数func_potential：","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"pvec = getPotenCavity.(zvec, par) + 畸变势阱\nfunc_potential = Spline1D(zvec, pvec)\n\nEJ, JJ, ΔJJ, zJθ, δJθ, ΦJθ, νsJ, ψJ, nJs = getDatas(200, 199, 3σz, funψzδ, func_potential, -0.0075, 0.0075, [-0.002740890061896845, 0.0027408900618968233], [0.0], 1360.4, par.η)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"得到采样之后，和上面一样的方法分析不稳定性：","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"rvec, gvec, tvec=scanNb(collect(0:0.02:1), 0.5 * 1e-9/elementcharge, JJ, ΔJJ, ψJ, νsJ, zJθ, ΦJθ, ωvec, imp_trans, 3, par)","category":"page"},{"location":"examples.html","page":"示例","title":"示例","text":"note: 要检查的地方\n一个是要检查纵向密度分布rho(z)是否正确、是否光滑。不光滑会导致径向密度分布psi(J)的错误。另一个要检查的是，径向密度分布psi(J)的积分：2 pi int_0^infty psi(J) dJ是否接近1。","category":"page"},{"location":"index.html#Home","page":"主页","title":"Home","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"这个Julia包是我研究双高频系统过程中，用到的函数库。","category":"page"},{"location":"index.html#Julia的使用","page":"主页","title":"Julia的使用","text":"","category":"section"},{"location":"index.html#Julia快速入门","page":"主页","title":"Julia快速入门","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"julia语法的入门可以到下面的网址去挑选你熟悉的语言比较它们的显著差异。","category":"page"},{"location":"index.html#Julia多线程支持","page":"主页","title":"Julia多线程支持","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"安装完Julia之后，在任务管理器中，点击“性能”-“CPU”，在右下角找到“内核”。如下图，内核数为16。 (Image: alt text) 然后Windows系统可以搜索“编辑系统环境变量”，在“环境变量”中添加变量，变量名：JULIA_NUM_THREADS，变量值为电脑内核数。 (Image: alt text) 对于Linux工作站，需要自己用代码查看其内核数，然后在.bashrc中使用export JULIA_NUM_THREADS=48添加环境变量。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"有测试表明，如果超过电脑内核数，计算速度反而会降低。因此，即使你电脑线程数更多，此设置也不要超过内核数。","category":"page"},{"location":"index.html#Julia编辑器的选择","page":"主页","title":"Julia编辑器的选择","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"我推荐几种编辑方式。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"比较小的项目，或者实验性程序，可以用Jupyter Notebook。这样可以边写代码，边记笔记。且VS Code可以远程打开工作站的Jupyter Notebook，非常方便。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"写大型项目，推荐原生VS Code或者国内改版的VS Code——Syslab。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"你如果电脑有VS Code且懒得装新编辑器，需要自己下载Julia编译器，然后安装VS Code Julia插件。并且在右上角“运行”图标右侧选择“Excecute active in REPL”。这会使得你当前打开的代码文件在REPL中运行——意味着函数、变量全部写入了REPL内存中，你可以在REPL内打印变量、导入绘图包观察函数关系。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"(Image: alt text)","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"你也可以选择同元软控的个人版或教育版Syslab。 它基于VS Code的开源代码，扩展了其功能，具有方便的绘图界面。可以像MATLAB那样，通过点击选择变量，然后有多种绘图方式提供选择。而且，由于是用VS Code改的，你可以使用VS Code的各种插件，比如CodeGeeX等等。 注意，Syslab内嵌Julia程序，你无需额外下载。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"如果你有教育邮箱，可以使用教育版，功能更全些。他们拿Julia官方开源代码拿来做了优化——比如Plots被他们改成了TyPlots，画的图更像MATLAB了。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"如果你没有教育邮箱，个人版Syslab也能用，只是会阉割掉部分同元做优化的库。我不是太喜欢。但是你仍然可以用] add 包名安装Julia官方的库。","category":"page"},{"location":"index.html#DoubleRF包的使用","page":"主页","title":"DoubleRF包的使用","text":"","category":"section"},{"location":"index.html#包依赖项的安装","page":"主页","title":"包依赖项的安装","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"一般注册过的包安装时，都可以用] add DoubleRFs来安装。同时依赖的包，比如FFTW,Interpolations,IntervalArithmetic等都会自动安装到本地来。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"然而我这种本地的包，暂时不知道怎么弄。首次在本机运行的话，暂时就通过手动添加的方式安装依赖项吧。以后要是想维护、拓展本包，这都是必要的。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"在julia REPL中，按下]进入包管理模式。然后输入：","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"add FFTW                    # 傅里叶变换相关\nadd Interpolations          # 插值相关\nadd IntervalArithmetic      # 区间算术\nadd IntervalRootFinding     # 基于区间算术的找根包，即使怀疑有根，也会告诉你\nadd QuadGK                  # 函数积分包\nadd LoopVectorization       # 向量化相关，增加计算速度\nadd CurveFit                # 曲线拟合包","category":"page"},{"location":"index.html#本地包的导入","page":"主页","title":"本地包的导入","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"使用时需要先将DoubleRFs包的路径——或者DoubleRFs的父级目录——添加到julia的搜索路径中。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"push!(LOAD_PATH, \"E:/Documents/JuliaProgram/MyModules/\")","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"这样就成功地将本地包路径添加到了julia搜索路径。这样可以在代码中import或者using调用包名。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"如果你存在多个设备，比如“办公室电脑”、“个人PC”、“Linux工作站”，那么可以用下面的方式添加目录：","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"try\n    global computername = ENV[\"COMPUTERNAME\"] # 获取Windows电脑名称\ncatch\n    global computername = ENV[\"HOSTNAME\"] # 获取Linux工作站名称\nend\nif computername == \"办公室电脑\" # 如果电脑名称为\"办公室电脑\"\n    push!(LOAD_PATH, \"E:/Documents/JuliaProgram/MyModules/\")\nelseif computername==\"localhost.localdomain\"    # 如果工作站名称为\"localhost.localdomain\"\n    push!(LOAD_PATH, \"/home/xujingye/Julia/MyModules\")\nend","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"你可以添加为VSCode或者Syslab的代码片段，下次能便捷输入。","category":"page"},{"location":"index.html#调用相关函数","page":"主页","title":"调用相关函数","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"调用的方式有两种：using和import。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"(1)如果你使用：","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"using DoubleRFs","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"来使用这个包了，那么所有在src/DoubleRFs.jl中通过export导出的函数，都可以直接调用；没有export的，也可以用DoubleRFs.函数名()调用。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"(2)如果你使用：","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"import DoubleRFs:one_turn_map","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"那么只能调用one_turn_map这个函数。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"(3)或者你用：","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"import DoubleRFs","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"这样你可以用DoubleRFs.one_turn_map来调用函数。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"import的好处是，只导入使用的函数，不怕命名冲突；而using会导入全部export的函数，可能会产生冲突。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"导入包或函数之后，具体的使用案例，参见“示例”一节：","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"Pages = [\"examples.md\"]","category":"page"},{"location":"index.html#文件结构","page":"主页","title":"文件结构","text":"","category":"section"},{"location":"index.html","page":"主页","title":"主页","text":"如果你想扩展自己的双高频函数包，你需要了解这里的文件结构。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"所有的函数都放在/src/文件夹中。其中DoubleRFs.jl与包名同名，这个文件很重要：向外提供了对接接口；向内管理着所有的函数。","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"DoubleRFs\n├── README.md\n├── Manifest.toml\n├── Project.toml\n├── src                             # 源代码\n│   ├── SimulationTools\n│   │   ├── ST_MappingEquation.jl   # 单圈映射方程，用来进行粒子多圈迭代\n│   │   │                           # 也可以保留历史坐标记录分析纵向振荡频率\n│   │   └── ST_SynchroTuneSpread.jl # 分析纵向振荡频率分布\n│   ├── GeneralTools\n│   │   ├── GT_CurveFit.jl\n│   │   ├── GT_Int.jl\n│   │   ├── GT_MatrixDerivative.jl\n│   │   ├── GT_Pad.jl\n│   │   ├── GT_Random.jl\n│   │   ├── GT_RemoveDataList.jl    # 早期测试阶段，我计算出来的角变量\n│   │   │                           # 由于精度问题，在某些位置总是波动很大\n│   │   │                           # 甚至超出(0, 2pi)范围，因此我利用\n│   │   │                           # 这个，移除过近的点、超出范围的点\n│   │   │                           # 不过后来不怎么用了，我们的库里实际没用过\n│   │   ├── GT_Sample.jl            # 分为两个部分：1. 根据密度分布函数进行\n│   │   │                           # 采样，这样一大群粒子在此坐标上的分布就\n│   │   │                           # 满足此函数；2. 径向密度分布的积分接近1.\n│   │   │                           # 我琢磨着除了目前的采样方式，是否存在适应\n│   │   │                           # 性采样能够让计算更少。于是参考了自适应\n│   │   │                           # Simpson法——对于梯形积分规则，斜率均匀\n│   │   │                           # 的地方采样少，斜率变化大的地方采样密集。\n│   │   │                           # 但是，密度分布斜率均匀就代表纵向工作点\n│   │   │                           # 分布斜率均匀吗？未必。所以实际上弃用。\n│   │   ├── GT_Sum.jl               # 偶然发现的精确求和法，电脑用二进制计算\n│   │   │                           # 却要显示为十进制，所以有时会将比如2显示\n│   │   │                           # 为1.9999999...。此求和法一定程度上能\n│   │   │                           # 解决这个问题。不过我怕影响性能，没用。\n│   │   └── GT_ZeroPoint.jl\n│   ├── DataAnalysis\n│   │   ├── DA_GrowthRate.jl\n│   │   └── DA_RMS.jl\n│   ├── ActionAngleVlasovSolver\n│   │   ├── Sample\n│   │   │   ├── AngleVariable.jl\n│   │   │   ├── AngularSampling.jl\n│   │   │   └── δJθ.jl.jl\n│   │   ├── TMCI_Main.jl\n│   │   ├── NumericalSpecialFunction.jl\n│   │   └── TMCI_InteractionMatrix.jl\n│   ├── DoubleRFs.jl\n│   ├── FixedPoints.jl              # 求不动点的相关工具\n│   ├── NormedDensity.jl\n│   ├── Voltage.jl\n│   ├── Potential.jl\n│   └── Hamiltonian.jl\n├── docs # 文档\n└── test","category":"page"},{"location":"index.html","page":"主页","title":"主页","text":"文件结构符号可以在这里打开。","category":"page"},{"location":"docs.html#文档编写","page":"添加函数与文档编译","title":"文档编写","text":"","category":"section"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"如果你觉得文档中说得不对、有歧义或想补充自己的想法。就需要更改这里的文档。","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"下面介绍更改文档的做法。","category":"page"},{"location":"docs.html#函数注释","page":"添加函数与文档编译","title":"函数注释","text":"","category":"section"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"参考src/目录下的函数注释方式，采用下面的格式装饰在函数前面：","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"@doc raw\"\"\"\n    getCavityVoltage(z, v1, r, ϕs, ϕ2s, h1, h, circum)::Float64\n\n这里添加函数说明。\n\"\"\"","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"上面的缩进，等同于代码块：","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"```julia\ngetCavityVoltage(z, v1, r, ϕs, ϕ2s, h1, h, circum)::Float64\n```","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"编译后，会先显示代码块，再显示函数说明。","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"同时，docs/src/的目录下会有不少.md文件，只要在其中加上","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"```@docs\ngetCavityVoltage\n```\n或者：\n```@docs\nDoubleRFs.getCavityVoltage\n```","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"即可编译。两者区别为：当DoubleRFs包没有export该函数时，需要用DoubleRFs.函数名.","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"注意编译时，会自动将各种多重分派的函数全部收集起来一起显示。所以，如果你存在函数进行了多重分派，那么只要在.md文件中声明一次，就会把所有同名的代码块注释编译过来。","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"如何在注释中使用LaTeX语法参考Documenter的链接，语法案例参考这里。","category":"page"},{"location":"docs.html#编译","page":"添加函数与文档编译","title":"编译","text":"","category":"section"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"当完成之后，切换进docs/目录，在终端中：","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"julia --project make.jl","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"即可编译文档。","category":"page"},{"location":"docs.html","page":"添加函数与文档编译","title":"添加函数与文档编译","text":"编译完成后，在docs/build/目录下即可找到生成的.html文档。","category":"page"}]
}
